### Java 多线程内存可见保证
1. jvm 层面，内存屏障
2. 上下文切换

### CPU 缓存一致性协议

#### Bus Snooping

1. 写失效，当处理器写入一个共享缓存块时，其他所有共享副本都会通过总线窥探（Bus Snooping） 失效，确保处理器只能读写一个数据的一个副本，
   - MSI，MESI，等
2. 写更新，当处理器写入一个共享缓存块时，其他所有共享副本都会更新，不常用，浪费总线带宽


### JMM 的内存可见性保证

按程序类型，Java程序的内存可见性保证可以分为下列3类单线程程序。
- 单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
- 正确同步的多线程程序，正确同步的多线程程序的执行将具有顺序一致性(程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
- 未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障:线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。未同步程序在JMM中执行时，整体上是无序的，其执行结果无法预知。JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。

未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。
1) 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行，比如正确同步的多线程程序在临界区内的重排序。
2) 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。
3) 顺序一致性模型保证对所有的内存读/写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性
(32位处理器)


### JVM层面的内存屏障
在JSR规范中定义了4种内存屏障:
- LoadLoad屏障:(指令Load1; LoadLoad; Load2)，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- LoadStore屏障:(指令Load1; LoadStore; Store2)，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- StoreStore屏障:(指令Store1; StoreStore; Store2)，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见
- StoreLoad屏障:(指令Store1; StoreLoad; Load2)，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能由于 x86只有 store load 可能会重排序，所以只有JSR的 StoreLoad 屏障对应它的 mfence 或 lock 前缀指令，其他屏障对应空操作



### 硬件层内存屏障
硬件层提供了一系列的内存屏障 memory barrier/ memory fence(Intel的提法)来提供一致性的能力。拿X86平台来说，有几种主要的内存屏障:
1. lfence，是一种Load Barrier 读屏障
2. sfence,是一种Store Barrier 写屏障
3. mfence,是种全能型的屏障，具备lfence和sfence的能力
4. Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD,ADC,AND,BTC,BTR,BTS,CMPXCHG,CMPXCH8B,DEC,INC,NEG,NOT,OR,SBB.SUB.XOR.XADD,and XCHG等指令,

内存屏障有两个能力:
1. 阻止屏障两边的指令重排序
2. 刷新处理器缓存!冲刷处理器缓存

> 对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据;
> 对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。 
> Lock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放，不同硬件实现内存屏障的方式不同，
> java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码


### volatile的内存语义
#### volatile的特性
- 可见性：对一个 volatile 变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。
- 原子性:对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性(基于这点，我们通过会认为volatile不具备原子性)。volatile 仅仅保证对单个 volatile 变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。
64位的1ong型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性
- 有序性:对 volatile 修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性。
  在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。为了提供一种比锁更轻量级的线程之问通信的机制，
  JSR-133专家组决定增强volatile的内存语义:严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。
#### volatile写-读的内存语义
- 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
- 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。


### 进程间通信
1. 管道(pipe)及有名管道(named pipe):管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信,2.信号(signal):信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
3. 消息队列(message queue):消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息;对消息队列有读权限得进程则可以从消息队列中读取信息。 
4. 共享内存(shared memory):可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
5. 信号量(semaphore):主要作为进程之间及同一种进程的不同线程之间的同步和互斥手段。
6. 套接字(socket):这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

#### 线程同步互斥
四种线程同步互斥的控制方法
- 临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。(在一段时间内只允许一个线程访问的资源就称为临界资源)
- 互斥量:为协调共同对一个共享资源的单独访问而设计的。
- 信号量:为控制一个具有有限数量用户资源而设计。
- 事件:用来通知线程有一些事件已发生，从而启动后继任务的开始。


### Thread 常用方法
#### sleep 方法
- 调用 sleep 会让当前线程从 Running 进入TIMED WAITING状态，不会释放对象锁
- 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException，并且会清除中断标志
  睡眠结束后的线程未必会立刻得到执行
- sleep当传入参数为0时，和yield相同

#### yield方法
- yield会释放CPU资源，让当前线程从 Running 进入 Runnable 状态，让优先级更高(至少是相同)的线程获得执行机会，不会释放对象锁
- 假设当前进程只有main线程，当调用 yield 之后，main 线程会继续运行，因为没有比它优先级更高的线程，
- 具体的实现依赖于操作系统的任务调度器

#### join方法
等待调用join方法的线程结束之后，程序再继续执行，一般用于等待异步线程执行完结果之后才能继续运行的场景


### Java 线程中断机制
- interrupt(): 将线程的中断标志位设置为 true，不会停止线程
- isInterrupted(): 判断当前线程的中断标志位是否为 true，不会清除中断标志位
- Thread.interrupted(): 判断当前线程的中断标志位是否为 true，并清除中断标志位，重置为false


### CAS
- ABA 问题（version no）
- 只能对一个共享变量的院子操作
- 自旋 CAS长时间不成功，会给 CPU 带来很大的开销

> atomicXXX 通过 cas 提供高并发下的原子操作
> longAdder, doubleAdder, 高并发场景下大量线程院子操作解决方案